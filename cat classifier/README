		Task 1: Histograma RGB
		Functia rgbHistogram creeaza un vector care reprezinta concatenarea histogramelor pentru fiecare matrice de culori R,G,B. Cu ajutorul functiei imread determin cele 3 matrice, cate una pentru fiecare culoare si memorez fiecare matrice intr-o variabila separata pentru a le putea prelucra mai usor. Histograma masoara frecventa de aparitie a pixelilor intr-o poza, insa cum spatiul RGB contine 256 de valori s-a decis impartirea acestuia intr-un numar de intervale reprezentat de parametrul count_bins. Algoritmul de determinare a histogramei pentru matricea asociata culorii R este urmatorul: instructiunea for este utilizata pentru a parcurge fiecare interval in parte; in matricea index_red verific care pixeli din matricea red_channel se incadreaza in intervalul [(i-1)*256/count_bins,(i-1)*256/count_bins + 256/count_bins) si pun 1 pe pozitiile acestora si 0 in rest; apoi creez un vector index_red_true in care pun toate valorile de 1 din matricea index_red; in final suma elementelor din index_red_true reprezinta frecventa de aparitie a pixelilor din intervalul respectiv. Aplic acelasi algoritm pentru G si B, iar in final concatenez cei trei vectori pentru a crea histograma RGB.
		
		Task 2: Histograma HSV		
		Functia hsvHistogram realizeaza conversia din RGB in HSV utilizand algoritmul prezentat in enunt dar vectorizat. Algoritmul pe care l-am implementat necesita transformarea matricelor de culori in vectori. Pentru aceasta trebuie sa luam in considerare modul de pozitionare al pozei atunci cand stabilim indicii. Daca o poza este asezata culcat ea va avea 80 de linii si 120 de coloane, iar daca va fi pozitionata pe verticala va avea 120 de linii si 80 de coloane. Pentru a calcula Cmax si Cmin folosesc o variabila auxiliara in care memorez maximul/minimul dintre primele 2 elemente iar apoi Cmax va fi egal cu maximul dintre aux si ultimul element. delta reprezinta diferenta dintre Cmax si Cmin. 
		Algoritmul prezentat in enunt transforma cate un pixel din RGB in HSV insa cu ajutorul functiei find putem vectoriza acel cod si elimina for-urile imbricate necesare pentru parcurgerea matricei pixel cu pixel, precum si conditiile din if. Functia find returneaza pozitia din vector sau matrice pentru toate elementele care indeplinesc o anumita conditie( aceasta conditie va fi cea din if-urile din algoritmul din enunt). Mai intai, cu ajutorul functiei find determin indecsii elementelor care respecta conditiile din fiecare if si memorez acesti indecsi intr-un vector cu nume sugestiv. Trebuie sa iau in considerare posibilitatea existentei unor valori comune pentru R,G si B. De aceea, determin mai intai indecsii pentru valorile unice si apoi determin indecsii pentru valorile comune pentru 2 matrice. In plus, trebuie sa verific ca delta este diferit de 0 pentru a nu imparti la acesta. Cu ajutorul vectorilor de indecsi, aplic formula de calcul pentru matricea H, utilizand operatorul element cu element(Hadamard). In cele din urma, normez matricea H. Pentru matricea S trebuie sa iau in considerare cazurile cand Cmax este nul si cand este nenul pentru a aplica formula respectiva, iar vectorul V este egal cu vectorul Cmax. 
		Pentru a realiza histograma, aplic algoritmul de la rgbHistogram, modificand dimensiunea intervalelor. Trebuie mentionat ca pentru a reduce erorile de calcul am inmultit cu 100 fiecare matrice.
		
		Task 3: Clasificare pisici
		In cadrul functiei preprocess trebuie sa creez vectorul de caracteristici(care contine histogramele) pentru fiecare poza din directorul de teste si vectorul de etichete care stabileste daca o poza este cu pisici sau fara. In primul rand, creez o variabila in care adaug la calea data ca parametru numele directorului cats/ sau not_cats/. Apoi utilizez aceasta noua variabila pentru a apela functia getImgNames si a memora numele tuturor pozelor din respectivul director intr-o matrice. Am realizat o matrice cu numele pozelor cu pisici si o matrice a numelor pozelor fara pisici, iar apoi le-am concatenat.
		In cadrul iteratiei for parcurg fiecare poza in parte din matricea Images si in functie de tipul histogramei dat ca parametru(fie RGB, fie HSV) memorez histograma respectiva in vectorul de caracteristici X. De asemenea, deaorece in matricea Images am pus la un loc atat pozele cu pisici, cat si pozele fara pisici trebuie sa pun o conditie suplimentara care sa verifice ce fel de poze prelucrez. Cum stiu ca nr_rows1 reprezinta numarul de poze cu pisici pun conditia ca indexul sa fie mai mic sau egal cu nr_rows1 pentru a stii ca prelucrez o poza cu pisici si a memora eticheta 1, si conditia ca indexul sa fie mai mare ca nr_rows 1 in caz contrar.
		In cadrul functiei learn creez vectorul de parametri w care ma va ajuta sa prezic daca o poza contine pisici sau nu. Pentru a crea acest sistem trebuie sa rezolvam sistemul X*w=t, mentionand faptul ca matricei X i-am adaugat o coloana ce contine numai 1. Pentru a calcula acest sistem, m-am gandit sa utilizez algoritmul Gram-Schmidt implementat in laborator pentru a descompune matricea X intr-o matrice ortogonala Q(cu proprietatea ca Q' = Q = inv(Q)) si o matrice superior triunghiulara R. Ca modificari aduse algoritmului mentionez vectorizarea for-ului ce calculeaza matricea R pentru elementele care se afla deasupra diagonalei principale si inlocuirea functiei norm care calculeaza norma lui aux cu o functie prezentata in laborator care mareste acuratetea. 
		Revenind in functia learn utilizez matricele Q si R pentru a rezolva sistemul astfel:
		X * w = t;
		Q * R * w = t;
		R * w = Q' * t;
		Pentru rezolvarea sistemului superior triunghiular implementam o functie care urmareste algoritmul descris in laboratorul 2.
		
		Task 4: Evaluare clasificator
		Functia evaluate ne ajuta sa determinam acuratetea cu care identificam pozele cu pisici si fara pisici si sa realizam o comparatie intre clasificarea ce utilizeaza histograme RGB si histograme HSV. Implementarea se face asemanator ca pentru functia preprocess in ceea ce priveste crearea matricei cu nume de poze si determinarea histogramelor. Diferenta consta in instructiunile din fiecare if, aici trebuind sa recream vectorul de caracteristici X si sa determinam produsul scalar y care ne ajuta sa prezicem daca o poza are pisici sau nu, astfel daca y >= 0 avem de a face cu o poza cu pisici, altfel poza nu contine pisici. Calculam separat numarul de poze identificate ce fie contin pisici, fie nu contin. Adunam aceste 2 variabile pentru a determina numarul total de poze identificate de noi si apoi impartim la numarul total de poze si inmultim rezultatul cu 100 pentru a calcula procentul imaginilor clasificate corect.
		Dupa rularea checkerului, observ ca acuratetea clasificarii cu ajutorul histogramelor RGB, anume 85.71%, este mai mica decat acuratetea clasificarii cu ajutorul histogramelor HSV, 91.27%. Mentionez faptul ca utilizarea uneia dintre definitiile normei pentru algoritmul Gram Schmidt in locul functiei octave norm a oferit o acuratete mai mare, procentele initiale fiind 84.92% pentru RGB si 90.48% pentru HSV. Motivul pentru care acuratetea clasificarii cu histograme HSV fata de cea cu histograme RGB poate fi acela ca histogramele HSV sunt calculate pentru intervale mai mici fata de histogramele RGB, ceea ce ofera o precizie mai mare si reduce propagarea erorilor.
